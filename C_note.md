# C语言 

## 第一章

### 1. 十进制转换二进制
（1）整数转换
除，反着写
（2）小数部分转换
小数点后 乘，正着写

### 二、八、十六进制转换
八进制基数 是2的三次幂
十六进制 2的四次幂

1. 二 ---> 八
 <u>001</u> <u>101</u> 

2. 八 ---> 二
	3位看

3. 二 ---> 十六
	4位  <u>1001</u>

### 2.  机器数表示形式
1.原码
符号位： 正0		负数1
正负数的原码都相同，符号位变化

2.反码
（正） 与原码相同
（负）求反
10101 -->(反)110101

3.补码
（正）与原码相同
（负）按位求反，末位加1

### 3. 二进制位运算
1. 与运算（&）
	有0则0，两同(1)才同(1)
2. 或运算（｜）
	有1则1，两个不同(0)才不同(0)
3. 非运算（～）
	求反
4. 异或运算（^）
	同0异1

题1：将二进制数10110010的高4位求反，低4位不变的操作是
	答：与(F0)16 按位异或




## 第二章程序设计基础
### 1.编制C步骤
编辑 -->编译-->链接

### 2.琐碎知识点
1. C语言是由多个函数构成

2. a --> 97

   A -->65 

   0 --> 48



## 第三章基本数据类型、运算符与表达式
### 1. C语言数据类型
1. 基本类型
	占字节：
		-1.int     	 2 / 4
		-2.short      2
		-3.long  	 4
		-4.float 	  4
		-5.double   8
		-6.char  	 1

### 2. 常量、变量和标识符
1. 标识符
	- 1. 命名规则：
		>由字母、数字、下划线组成
		>第一个字母必须是字母或下划线
		>关键字不能做变量名

2. 常量
	- 用#define定义
	- 注意：
	
	 			1. 定义时，行尾不能有分号
	 			2.define是预处理命令，不是C语言语句
3. 变量
	必须先定义，后使用

### 3. 简单数据类型与表示范围
1. 整型数据
	- 1. 整型常量
		八进制--> 0开头
		十六进制--> 0x开头

2. 内存表示
	**正数的数值在内存中用补码的形式存放**
>小例子：
> -65537：对于16位单元来说，先计算补码： 01 0000 0000 0000 0001-->（求反+1）10 1111 1111 1111 实际存放的为1111 1111 1111 1111 为 -1 而不是 -65537
> 同理： 65535 存放是1 
>  -65535 存放是 1

3. 实型数据
  - 1. 指数形式
  	a E n , a为十进制数， n为十进制整数
  - 2. 实行变量分类和定义
      >1. 单精度： float -->%f
      float 小数点后要有六位。
      最多能表示八位数字，如果没到八位，最后追加的数字是随机的

      >2. 双精度：double -->%lf
      

4. 常用转义字符及其含义
- 1. 字符型常量
>1. 转义字符算一个字符
>2. \\ \表示 \  ;     \"表示 "
>3. \ddd : 1~3位八进制数 所代表的字符，d的值可以是 0～7 的任意数字 
>4. \xhh：1～2位十六进制数所代表的字符， h的值可以是 0~f的任何字符
```c
char a = '\' ; //报错
char a = '\x'; //报错
char ch = '\2344'; //错！八进制最多有3个 ；正：'\234'
char ch = '\x23w'; //错，x后只能有1～2位
strlen("\123456"); // 4位数: \123 4 5 6
strlen("\x234"); //报错
```

- 2. 字符串常量
	> 1. 字符常量只能是单个字符，字符串常量可以含一个或多个字符
	> 2. 字符常量占1个字节的内存空间

 	>	3. 字符串常量占的内存字节数等于字符串中字节数+1
 	> +1的这个字节中存放字符'\0' (ASCII 码为0)
 	>	sizef() --->字节数+1
 	>	strlen --->字节数

5. 简单数据类型的表示范围
	- 1. 整型
		int(16) , 2字节 , -32768 ~ 32767
		short ,2字节 , -32768 ~ 32767
		unsigned int(16) , 2字节 , 0~65535
		unsigned short  , 2字节 , 0~65535
		char , 1字节 , -128 ~ 127
		unsigned char , 1字节 , 0 ~ 255

6. 数据简单输出
	- 1. 格式控制字符：
	>%d:有符号整型，int、 short
	%u:无符号
	%f:float
	%c:字符型，char
	%s:字符串

7. 强制类型转换符
	- 1. 自动转换
	（1）无符号 短 --->长
	高位补0
	（2）有符号 短--->长
	高位补第一位的数字
	- 2. 强制转换
	long double 
	⬆️
	double  < ----    float 	（只要有float就会转乘double）
	⬆️
	long
	⬆️
	unsigned int 
	⬆️
	int < ----- char , short
	(从右到左是必须转换的)

### 4. 运算符和表达式
1. 算术运算符、算术表达式
	- 1. 算术运算符
		%只能用于整数
		优先级：类型强制转换运算符>算术运算符>赋值运算符
	- 2. 自增自减运算符、负号运算符
		前置运算--->  ++ / -- 变量：先增/减 后运算
		后置运算--->  变量++ / -- ：先运算 后增/减 
>使用方法：
>1:i+++j :相当于(i++)+j 先将i+j赋值给p,然后i增1
>2:i+++--j：相当于(i++)+(--j) 先对j减1，然后算i+j
>3:i+++i++: 相当于(i++)+(i++)想将i+i赋值，再自增2次
>4:++i+(++i):相当于(++i)+(++I)先把i自增2次，然后算i+i

2. 位运算符、位运算表达式
	- 1. 左移运算(<<   乘2)
	高位丢掉，空出的低位用零填补
	- 2. 右移运算（>>   除2）
	空出的高位用原来的符号填补（负用1，正用0）
	- 3. 移位运算符必须都是整型数

### 5. 运算符的优先级和结合性
```c
	<从下到上，从低到高>
	>()
	>~;++;--;-(负号);sizeof				从右向左
	>*;/;%
	>+;-(减法)
	><<;>>
	>&
	>^
	>|
	>=;+=;==;/=;*=;%=;^=;&=;|=     从右向左
	>,
```
### 6. 琐碎知识点
1. %只能用于int 和char 型变量
2. m是个三位数，从左到右用a , b , c表示		
	-->百：m/100;  十：(m/10)%10;  个：m%10





## 第四章 基本输入/输出
### 1. 格式化输出printf
1. 整数的输出
	%  [-] / [+] / [.] / [width] / [l] / [h]
	>[-]：表示输出的数据左对齐，默认右对齐
	>[+]：表示加上+号
	>[width]：无符号整数，表示输出整数的最小域宽（占屏幕的多少格）
	>[.] :无符号整数，表示至少要输出多少位，如果整数的位数小于这个数，需要在左边的空位上补0
	>[l]：输出长整型数据
	>[h]：输出短整型数据

```c
    int a = 123;
    long L = 65537;
    printf("a=%6d-----(a=%%d)\n",a);
    //输出：a=   123-----(a=%6d)
    printf("a=%-6d-----(a=%%-6d)\n",a);
    //输出：a=123   -----(a=%-6d)
    printf("a=%-06d-----(a=%%-06d)\n",a);
    //输出：a=123   -----(a=%-06d)
    printf("a=%+06d-----(a=%%+06d)\n",a);
    //输出：a=+00123-----(a=%+06d)
    printf("a=%+6.6d----(a=%%+6.6d)\n",a);
    //输出：a=+000123----(a=%+6.6d)
    printf("a=%-6.5d-----(a=%%-6.5d)\n",a);
    //输出：a=00123 -----(a=%-6.5d)
    printf("a=%6.4d-----(a=%%6.4d)\n",a);
    //输出：a=  0123-----(a=%6.4d)
    prinf("%hd",L);
    //输出：1 ，65537的十六进制：0x0001 0001 ，取低十六位，则为1
```

2. 实数的输出
	
	% [.] / [#] / [width] / [.] / [l|L]
>[#] :必须输出小数点,如果是别的进制，如八进制，需要把前面的0输出来
>[.] :规定输出实数时，小数部分的位数
>[l] :输出double型数据；默认也是输出double数据
>[L] ：输出long double 型数据

3. 字符和字符串的输出
	输出字符： %[-] / [0] / [width]  c
	输出字符串： %[-] / [0] / [width] /[.] s
>[.] :表示只输出字符串的前多少个字符

注意：
>1:如果上一个不正常的输出会影响到下一个表达式的正常输出
>	 如：printf("a = %d, b = %d\n",f,b)  // float f =2; int a =10,b=100;
>	 输出的f用了float但是用了%d，则不会正常输出2.000000
>	 后面的b会被影响输出

### 2. 格式化输入scanf
>scanf("格式控制字符串",变量地址);
>&只能作用于变量，不能作用于表达式，因为表达式不对应具体的内存单元，没有地址，只有值

1. 控制符
 \* ：为抑制符，输入的数据不会复制给相应的变量
2. 注意：
	>使用格式控制符%c输入耽搁字符时候，空格和转义字符均作为有效字符被输入
	>scanf("%2d%*2d%3d",&num1,&num2);  // 输入123456789
	>printf("num1=%d,num2=%d\n",num1,num2); //读取12赋值给num1；读取34舍掉；读取567赋值给num2. 输出结果：num1=12 , num2=567

### 3. 字符数据的非格式化输入和输出
1. 字符数据的非格式化输入
	- 1. getchar
			该函数没有参数，有一个int型返回值。
			调用该函数的时候，程序就等待用户按键
	- 2. getc
			int getc (FILE \*stream);
			从流文件stream中读取一个字符信息，当流文件时stdin时，和getchar完全相同
	- 3. getche
		int getche(void);
		和getchar相同，唯一差别是：getche直接从键盘获取键值，不等待用户按回车键，只要用户按，则getche直接返回用户按键的ASCII码，同事用户输入的字符回显在屏幕上。
	- 4. getch
		和getche功能相同，唯一差别为：getche回显输入的字符，但是getch不回显输入的字符。

2. 字符数据的非格式化输出
	- 1. putchar
		现实输出的字符
	- 2. putc
		将字符输出到流文件stream，如果流文件为stdout，功能与putchar相同
	- 3. puts
		将字符串string的所有字符输出到屏幕上，<u>输出时将自动回车换行</u>

3. 清除键盘缓冲区
	fflush

### 4. 碎小知识点
1. 格式转换符中，除了X、E、G以外，其他均为小写字符。
2. 算法的描述方法：自然语言描述、伪代码、流程图、N-S图




## 第五章选择结构程序设计
### 1. 关系运算符、逻辑运算符、条件运算符
1. 关系运算符，关系表达式
	
	>(优先级) 算术运算符>移位运算符>关系运算符>&、 |、 ^>赋值运算符
	>
	>[> , >= , < , <= 的优先级大于== ,  !=]
	
2. 逻辑运算符，逻辑表达式

   | 逻辑运算符 | 含义                         | 结合性 |
   | ---------- | ---------------------------- | ------ |
   | !          | 单目运算符，逻辑非，表示相反 | 右结合 |
   | &&         | 双目运算符，逻辑与，表示并且 | 左     |
   | \|\|       | 双目运算符，逻辑或，表示或者 | 左     |

   ||：两边式子只要有一个式子为真，整个逻辑表达式的值就是真（即为1），否则为假（0）。
   &&：两边都是真，才为真，有一个不真则是假。&&优先级>||

   >**逻辑与，左边为0，则右边的不进行计算！！**
   >例子:
   	```c
   	int a = 1, b = 2, c = 3, d = 4, m = 2, n = 2; 
    	//执行 (m=a>b)&&(n=c>d)后的N的值为：
   	  //左边的M 为0；则后面的 n=c>d 不进行计算，n的值为2.
   	```

   ！：单目运算符，当右边的式子为真，整个为假；否则为真。

   >(优先级) !、~、++、--、sizeof > 算术运算符 > 移位 > 关系 > &、|、^ > &&、|| > 赋值

3. 条件运算符和条件表达式
	条件运算符为？和：，这是一个三目运算符
	**条件表达式的一般形式为：表达式1 ? 表达式2 : 表达式3**
	
	<规则>：如果表达式1的值为真，则表达式2的值作为条件表达式的值，否则以表达式3的值作为整个条件表达式的值。
	使用条件表达式时，还应注意以下几点：
	
	>1.条件运算符可嵌套，例如：x > 0? 1:(x < 0 ? -1 : 0) 表达式的值是：如果X是正数，则是1，如果是负数，则为-1，如果为0，则为0.
	>2.条件运算符 ? 和 : 是一堆运算符，不能分开单独使用。
	>![](picture/5_1.png)
	> [> , >= , < , <= 的优先级大于== ,  !=]
	>位运算符： & > ^ > |  (第一章 0，1那个)
	>逻辑运算符：&& > ||


### 2. 选择结构的程序设计
#### 1. IF语句
1. if 语句
表达式：
```c
if(表达式)
  语句;
```
2. if-else 语句
表达式：
```c
if(表达式)
 	语句1;
else
  语句2;
```

3. if-else-if 语句
```c
if(表达式1)    语句1;
else if(表达式2)  语句2;
else if(表达式3)  语句3;
else  语句N;
```
4. 注意
	- 注意关键词之后均为表达式，注意 真，非
	- C语言规定，在缺少{ }时，else 总是和它上面离他最近的为配对的if 配对

#### 2.switch语句
1. 介绍
格式：
```c
//形式：
switch(表达式){
case 常量表达式 C1: 语句组1;
								break;
case 常量表达式 C2: 语句组2;
								break;
default: 语句组;
			break;
			}
```


2. 执行过程为：

- 当switch后面“表达式”的值，与某个case后面的“常量表达式”的值相同时，就执行case后面的语句组；当执行到break语句时，跳出switch语句，转向执行switch语句的下一条。
- 如果没有任何一个case后面的“常量表达式”的值与“表达式”的值匹配，则执行default后面的语句，在执行switch语句的下一条

注意：
>1. switch后面的表达式，可以是<u>int 、 char 和枚举类</u>中的一种
>
>2. case后面的表示的值需要不相同。
>
>3. case后面必须是常量表达式，不能含变量
>	如果后面的是常量，可以考虑用if-else-if
>	
>4. 多个case子句，可以使用同一个语句，最后break。
>
> ```c
>   case 1:
>   case 2:
>   case 3: b+=2;break;
> ```
>
>5. switch语句可以嵌套
>
> ```c
>   void main(){
>   int x=1,y=0,a=0,b=0;
>   switch(x){
>   	case 1: switch(y){
>   					case 0: a++; break;
>   					case 1: b++; break;
>   					}
>   	case 2: a++; b++; break;
>   	case 3: a++; b++; break;
>   }
>   printf("%d ,%d",a,b);
>   }
> ```
>6. 几个小案例，具体看文件：<chapter5_book.c>

#### 注意事项

1.表达式

>1. 对于表达式(k)?(i++):(i--)来说，其中的表达式k等价于 <u>k!=0</u>
>解释：表达式可以理解为：k为真返回i++ ; k为假返回i--
>C语言中非0表示真，0表示假，k为真用k!=0表示
>2. 与运算，左为0，右边不算


## 第六章 循环结构
### 1  循环结构的程序设计
#### 1. while 语句

```c
  while (表达式) //表达式中可以是任意类型的表达式
  语句;	 //循环体
```
执行过程：
>首先判断表达式的值是否是真（非0），如果是真，则执行循环体内的语句，然后再判断表达式是否为真，如果是真，在执行循环体内的语句，如此往复，直到表达式为假（0）为止。

注意：
>1. 如果while后面的表达式一开始就是假，循环体讲一次也不执行
>2. 退出循环：1）：表达式为假（0） 
>						          2）：循环体中遇到break，return，goto 语句
>3. 要注意循环变量的增值，如果不增，很容易变成死循环

```c
	#include<stdio.h>
	void main(){
		int m, n, r;
		printf("Please input two postive inteager:\n");
		scanf("%d%d",&m, &n);
		while(n != 0)
		{
		r = m % n; //求余数
		m = n;
		n = r;
		}
		printf("Their greatest common divisor is %d\n",m);
	}

```

#### 2. do- while语句
1. 一般形式
```c
do
	语句;  //循环体
while(表达式); //循环条件
```
执行过程：
>首先执行循环体内的语句，然后才判断表达式的值是否为真（非0），如果为真，则再执行循环体内的语句，如此循环往复，知道表达式的值为假（0）为止。

注意：
>1. do-while语句和while语句的区别的在于do-while是先执行后判断，因此<u>do-while至少要执行一次循环体</u>。而while是先判断后执行，如果条件不满足，则循环体语句一次也不执行。
>2. 如果 do-while 后的表达式的值一开始就是假，循环体还是要执行一次
>3. <u>do-while语句的表达式后面必须加分号。</u>



#### 3. for 语句
1. 一般形式
```c
for(表达式1;表达式2;表达式3)  //循环条件
	语句;  //循环体
```
要求：
>表达式1:一般为赋值表达式，给控制变量赋初值。
>表达式2：关系表达式或逻辑表达式，循环控制条件。
>表达式3:一般为赋值表达式，给控制变量增量或减量

执行过程：
>首先，求表达式1的值，然后判断表达式2是否为真（非0），如果为真，则执行循环体语句，然后求表达式3的值。接下来再判断表达式2是否为真，如果为真，继续执行循环体语句以及求表达式3的值，直到表达式2为假为止。

#### 4. break 与 continue 语句
1. break语句
	break语句的作用是在循环体中测试到应立即结束循环时，使控制立即跳出循环结构，转而执行循环语句后的第一条语句。

	注意：
	>1. break只能用于while、do-while、for语句构成的循环结构中和switch选择结构中。
	>2. break语句只能终止并跳出包含它的最近一层的循环体。
	>3. 在嵌套循环的情况下，如果想让break语句跳出最外层的循环体，需要设置标志变量tag，然后在每层循环后加上一条语句: if(tag) break; 其值为1表示跳出循环体，为0则不跳出。

2. continue语句
**continue语句和break语句不同，当在循环体中遇到continue语句时，程序将跳过continue语句后面尚未执行的语句，开始下一次循环，即只结束本次循环的执行，并不终止整个循环的执行。**

注意：
>1. continue语句只能用于while、do-while、for语句构成的循环结构中。
>2. 在嵌套循环中，continue语句只对包含它的最内存的循环体语句起作用。

#### 5. go to 语句
goto语句也称为无条件转移语句。
```c
	goto 语句标号;
	
	语句标号;
```

应用：
>1. goto 语句可与条件语句配合使用来实现条件转移，构成循环
>	```c
>		int tag = 0;
>		for(...)
>	{
>		while(...)
>																																																																												
> 	{
> 	  ..
> 	   if(..) goto stop;
> 	..
> 	}
> 	 ..
> 	}	
> 		stop:for循环后第一条语句
> 	```
>	2. 在嵌套循环的条件下，利用goto语句可以直接从最内层的循环体跳出最外层的循环体。

#### 6. exit()函数

`void exit(int status);   头文件<stdlib.h>`
exit( )作用时：终止整个程序的执行，强制返回操作系统

### 2 循环结构类型的选择和转换
1. 循环结构类型选择
>1. 如果循环次数在循环体之前就已经确定，一般使用for 循环；如果循环次数时由循环体的执行情况确定的，一般用while循环或者do-while循环。
>当循环体至少执行一次时，使用do-while循环，反之，如果循环体可能一次也不执行，使用while循环。

2. 循环结构类型之间的相互转换


### 3 循环结构程序设计
1. 验证哥德巴赫猜想：任意充分大的偶数，都可以用两个素数之和表示。
```c
/*
思路：输入一个偶数N，将它分为p和q，使= p + q;
让p从2开始，每次增加1，而令q = n - p;如果 q and p是素数，则正为所求，否则令p = p + q再尝试。

要点：判断是否是素数，我们可以领两个表示量：flagp,falgq,初始值为0；若p是素数，令flagp =1,若q是素数，令flagq=1

*/

	#include<stdio.h>
	#include<stdlib.h>
	#include<math.h>
	
	void prime_number(){
		int i, n, p, q, flagp, glagq;
		printf("please input n:");
		scanf("%d",&n); 
		if(n<4 ||n%2!=0) //如果这个数不是偶数
		{
			printf("input data error!\n");
			exit(-1); //程序结束
		}
		
		p=1;
		do{
			p++;
			q = n - p;
			//Determine whether p is prime
			flagp = 1;
			for(i=2;i<=(int) sqrt(p);i++){
			if(p % 1 ==0){
				flagp=0;
				break;
			}
			}
			//Determine whether p is prime
			flagq = 1;
			for(i =2; i<=(int)sqrt(q);i++){
				if(q % i ==0){
					flagq = 0;
					break;
				}
			}
		}while(flagq * flagq ==0); //p q 中有一个不为素数时，继续循环
		printf("%d = %d + %d\n",n,q,p);
	}
```

2. 打印大小可变的菱形图案
```c
	/*
							*
						* * *
					* * * * *
				* * * * * * *
				  * * * * *
				    * * *
              *
关键：1. 确定每行*的个数：当行数i(假设最上面的一行为第一行)<=(size+1)/2时，该行的个数为 n = 2*i-1 ；
否则，n = 2*(size-i+1)-1；
	*/
#include<stdio.h>
#include<stdlib.h>

void rhombus()
{
		int i, j, k, m, n, size;
    pritnf("input size:"); 
    scanf("%d",&size);
    if(size <=0 || size %2 ==0)
    {
    	printf("error!\n");
    	exit(-1);
    }
    for(i = 1;i<=size ;i++) //控制行数
    {
    	n = (i<=(size+1)/2)?i:size-i+1; //每行中"*"号的个数
    	n=2*n-1;
    	m=(size-n)/2+15; //每行打印 * 之前应打印的空格数
    	for(k=1;k>=m;k++)  //打印每行前面的空格
    		printf(" ");
    	for(j =1;j<=n;j++) //打印每行的 *
    		printf("*");
    	printf("\n");  //打印一行后，回车换行
    }
}

```

3. 统计两个整数之间的所有整数中0、1、2、3、4、5、6、7、8、9数码的个数
```c
/*
	问题的关键在于要计算某整数中包含的各个数码的个数，必须对该整数进行分解，求得包含的各个数码，其方法可以通过每次除以10取余数得到，然后对商进行同样的处理，直到商为0时为止。
*/
#include<stdio.h>
#include<stdlib.h>

void statistics(){
	int num1, num2;
	int n,s,r;
	int count0=0,count1=0,count2=0,count3=0,count4=0,count5=0,count6=0,count7=0,count8=0,count9=0;
	printf("input two intrger:");
	scanf("%d%d",&num1,&num2);
	if(num1<0||num2<||num1>num2){
		printf("input error!\n");
		exit(-1);
	}
	for(n=num1;n<num2;n++){
		s = n;
		do{
			r =s % 10;
			switch(r){
					case 0:count0++;break;
					case 1:count1++;break;
					case 2:count2++;break;
					case 3:count3++;break;
					case 4:count4++;break;
					case 5:count5++;break;
					case 6:count6++;break;
					case 7:count7++;break;
					case 8:count8++;break;
					case 9:count9++;break;
			}
			s = s / 10;
		}while(s != 0);
	}
	printf("0 == %-4d  1 -- %-4d 2 -- %-4d 3-- %-4d\n",count0,count1,count2,count3);
	printf("4 == %-4d  5 -- %-4d 6 -- %-4d 7-- %-4d\n",count4,count5,count6,count7);
	printf("8 -- %-4d 9 -- %-4d\n",count8,count9)
}

```
4. （重要）利用下面的公式求PI 的近似值，要求累加到最后一项小于10的-6次幂为止。公式：PI /4 ~1-1/3+1/5-1/7....

```c
	#include<stdio.h>
	#include<math.h>
//累加项可以找规律 t = s / n; 其中s可以用s = -s实现; n按照1，3，5变化，n = n+2
void main(){
  int s =1;
  float n =1.0, t =1, pi=0;
  while(fabs(t)>=1e-6){
    pi +=t;
    n+=2;
    s=-s;
    t = s/n;
  }
  pi *=4;
  printf("pi = %.6f\n",pi);
}

```


### 4  注意事项
1. 需要在do-while循环语句的后面一定要加分号
2. while循环是先判断后执行，而do-while循环是先执行后判断。
while循环中循环一次可能不执行循环体，而do-while语句是要执行一次循环体。
3. break语句在循环体中的作用是：跳出循环结构，转而执行循环语句后的第一条语句
4. continue语句在循环体中的作用是：结束本次循环，循环执行下一次循环
5. 注意：
```c
	t =0;
	while (printf("*")){ //这里的意思为： 返回字符串中*字符的个数，这里是一个，所以返回1，相当于while(1)；这个相当于循环控制表达式与'0'等价
			t++;
			if(t<3)
				break;
	}
```


## 第七章 数组
### 1 一维数组
#### 1. 一维数组的定义和引用
1. 定义
`存储类型符  数据类型符  数组变量名[整型常量表达式]`
说明：
>1. 数组定义时，必须指定数组的大小，数组大小必须是整型常量表达式，不能是变量活变量表达式
>2. 计算数组所占内存单元的字节数的公式：
>		数组所占内存单元的字节数 = 数组大小 * sizeof(数组元素类型)

2. 一维数组的引用
数组是一种数据单元的序列，不能直接存取整个数组，只能引用数组中的各个数据单元。
引用数据单元的格式为：`数组变量名[下标]`
下标的最小值是0，最大值则是数组大小减1。

#### 2. 一维数组的赋值
1. 一维数组的初始化赋值
格式：`数据类型符 数组变量名[常量表达式] = {表达式1，表达式2，....，表达式n};`
```c
	//例如:
				int a[4] = {1,2,3,4}
				/*
				a[0]=1,
				a[1]=2,
				a[2]=3
				a[3]=4
				*/
```

注意：
>在定义数组时，如果没有为数组变量赋初值，那么就不能省略数组的大小。而且数组不初始化，其数组元素的值为随机值。

<b>赋值方法:</b>

（1）使用赋值语句来逐一赋值

适用于长度较小的数组或对长度较大的数组部分元素赋值。

```c
int a[4];
a[0]=1;a[1]=2;a[2]=3;a[3]=4;
char str[80];
str[0]='b';str[1]='y';str[2]='e';str[3]='\0';
```

（2）使用循环语句来逐一赋值
适用于对某数组元素进行有规律的赋值或接受用户通过键盘输入对数组元素的赋值。

```c
	int a[10],i;
	for(i=0;i<10;i++)
	a[i] = 2 * i + 1;
		
	//接受用户解盘输入赋值给数组各元素
	int b[10],i;
	for(i=0;i<10;i++)
		scanf("%d",&a[i]);
```

（3）使用memset函数赋值
标准库函数memset可实现对某内存块的个字节单元整体赋<u>同样的数值</u>。
`void *memset(void *s, char ch, unsigned n)`
功能：将s为首地址的一片连续的n个字节内存单元都赋值为ch（注意：是对内存的每个字节单元都赋值为ch）
	
（4）使用memcpy函数实现数组间的赋值
对于两个数据类型和大小相同的数组，如果将其中一个数组各单元的值要赋值给另一个数组的个数据单元，我们可以使用循环赋值也可以使用memcpy函数
`void *memcpy(void *d, void *s, unsigned n)`
功能：<u>将s为首地址的一片连续的n个字节内存单元的值拷贝到以d为首地址的一片连续的内存单元中</u>。

2. 一组数组的应用举例
（1）输入一行字符，统计其中各个大写字母出现的次数
```c
#include<stdio.h>
#include<memory.h>
void statistics_array(){
	char ch;
	int num[26],i;
	memset(sum,0,26*sizeof(int)); //初始化数组num
	while((ch = getchar())!='\n'); //输入字符串，判断统计
		if(ch>='A' && ch<='Z') //是否为大写字母
			num[ch-'A']++;
	
	for(i = 0;i < 26;i++){
		if(i%9 = 0)
			printf("\n");
		printf("%c(%d)",'A+i',num[i]);
	}
	printf("\n");
}

```

（2）用冒泡排序法讲10个整数按照从小到大的顺序排序
```c
/*
思路：假设数组又N个数组元素，采用冒泡排序法对该数组进行排序，从下标为0的元素开始，比较相邻的两个元素的大小，每次比较如果前面的元素大于后面的元素，则交换这两个元素的值。
每一轮冒泡排序都能有一个最大/最小值归位
*/
#include<stdio.h>
#define NUM 10
void pop(){
	int a[NUM], i, j, t;
	printf("input %d number \n",NUM);
	for(i=0;i<NUM;i++)
		scanf("%d",&a[i]);
		
	for(i= 1；i<NUM；i++) //轮次共NUM-1次
		for(j=0;j<NUM-i;j++) //实现一次冒泡操作
			if(a[j] > a[j+1])
				{
					t = a[j];
					a[j] = a[j+1];
					a[j+1] = t;
				}
	printf("the sorted numbers:\n");
	for(i=-;i<NUM;i++)
		printf("%d",a[i]);
}

//改进后的冒泡操作
void updatepop(){
	int a[SUM], i, j, t;
	int flag;
	printf("input %d number \n",NUM);
	for(i=0;i<NUM;i++)
		scanf("%d",&a[i]);
	
	for(i= 1；i<NUM；i++) //轮次共NUM-1次
		{
			flag = 0;
			for(j=0;j<NUM-i;j++) //实现一次冒泡操作
				if(a[j] > a[j+1])
					{
						t = a[j];
						a[j] = a[j+1];
						a[j+1] = t;
						flag =1;
					}
					if(flag ==0) break;
				}
	printf("the sorted numbers:\n");
	for(i=-;i<NUM;i++)
		printf("%d",a[i]);
}
}
```

### 2  二维数组
#### 1. 二维数组的定义和引用
`存储类型符 数据类型符 数组变量名[整型常量表达式1][整型常量表达式2]`
应用格式：`数组变量名 [下标1] [下标2]`
规定相同，都是从0开始到该维长度减1
二维数组在屋里上采用按行存储的顺序存储方式，我们称这种存储顺序为以行序为主序的顺序存储结构
>对于数据单元在内存的地址可通过下面的公式计算：
>有效地址=数组的起始地址+（下标1 *第一堆大小 + 下标2）*sizeof(元素类型)

#### 2. 二维数组的赋值
1. 二维数组的初始化赋值
（1）分行初始化
`存储类型符 数据类型 数组变量名[行常量表达式][列常量表达式] = {{第0行初值表},{第1行初值表}...{最后1行初值表}};`
例子：`int a[2][3] ={{1,2,3},{4,5,6}};//对数组元素全部赋值`

注意：可以省略前者部分赋值，但是必须要写出第二维的大小

`int a[][3]={{1,2},{4}};//对数组元素部分赋值，省略第一维大小`

（2）按元素在内存中的排列顺序初始化赋值
`存储类型符 数据类型 数组变量名[行变量表达式][列变量表达式] ={初值表};`
赋值规则：按二维数组中元素在内存中的排列顺序，将初始表中的数据，依次赋给各个元素。
例子：`int a[2][3]={1,2,3,4,5,6};//对数组元素全部赋值`

2. 二维数组在程序中赋值
	可以使用库函数memset/memcpy等方法来进行
	例子：`memset(a,0,6*sizeof(int)); //可以把数组中的个元素清0`
	`int b[2][3];memcpy(b,a,6*sizeof(int)); //将数组a个元素的值赋值到数组b的个元素中` 

### 3  字符串和数组
#### 1. 字符串本质
字符串是一种字符型数组，并且这个数组的最后一个单元的是'\0'，也就是说，字符串是一种以'\0'结尾的字符数组
```C
char str[]="china"; //数组大小为6
//等价于：
char str[]={'c','h','i','n','a','\0'};
```
注意：
>在用字符串数组来存放某个字符串常量时，如果要指定字符数组的大小，那么其大小至少要比字符串的长度大1（多了一个单元用于存'\0'）

#### 2. 字符及字符串操作的常用函数
1. 字符串的输入
（1）gets函数
`gets(字符数组变量名);`
功能：接受键盘的输入，将输入的字符串存放在字符数组中，直到遇到回车换行符时返回。但是回撤换行符'\N'不会作为有效字符存储。gets函数能接受包含空格字符的字符串。
注意：
>用于接受字符串的字符数组定义时的长度应足够长，以便保存整个字符串和字符串结束标志，否则，函数将把超过字符数组定义的长度之外的字符顺序保存在数组范围之外的内存单元中。

（2）scanf函数
在输入字符串时使用%s格式控制符，并且与%s对应的地址参数应该是一个字符数组，任何时候都会忽略前导空格，读取输入字符并保存到字符数组中，直到遇到空格符或回车符输入操作便终止了。scanf函数会自动在字符串后面加'\0'
为了避免输入的字符长度超过数组的大小，可以使用%ns格式控制符，N代表域宽限制，如果没有遇到空格字符，那么读入操作将在读入N个输入字符之后停止。

2. 字符串输出
（1）puts函数
`puts(字符串地址);`
将字符串中的所有字符输出到终端上，输出时将字符串结束标'\0'转换成换行符'\n'，使用puts函数输出字符串是无法进行格式控制

（2）printf函数
printf函数在输出字符串时，使用%s格式控制符，并且与%s对应的地址参数必须是字符串第一个字符的地址，printf函数将依次输出字符串
输出字符串时还可以定义更多的格式，%ns可以同时制定字符串显示的宽度。如果字符串的实际长度小于N个字符，不足部分填充空格。
N为正数，则在左端补空格，即字符串右对齐。
N为负数，则字符串做对齐，如果字符串的长度大于N个字符，则显示整个字符串。
```c
	printf(">>%8s<<\n","John");
	printf(">>%-8s<<\n","John");
	printf(">>%8s<<\n","John Smith");
	
	输出结果时：
	>>    John<<
	>>John    <<
	>>John Smith<<
```

3. 字符串的长度
求字符串长度的库函数 Strlen
`strlen(字符串的地址);`
功能：返回字符串中包含的字符个数（不包含'\0'），即字符串的长度。注意，字符串的长度是指从给定的字符串的起始地址开始到第一个'\0'为止。
注意：
>字符串中需要注意转义字符
>char str[ ]="0123<u>\045</u>6789";
>printf("%d",strlen(str));  //输出结果为9，将把\045作为一个转义字符来看待
>printf("%d",strlen(&str[5])); //输出结果为4

4. 字符串的复制
  字符串的复制不能使用复制运算符“=”，而必须使用strcpy、 strncpy 、memcpy函数
  （1）strcpy函数
  `strcpy(字符数组1,字符串2);`
  功能：将**字符串2复制到字符数组1中去（包括\0）**strcpy的第一个参数必须是一个字符数组变量，也可以是一个字符串常量。

（2）strncpy函数
`strncpy(字符数组1,字符串2,长度n);`
功能：**将字符串2的前N个字符复制到字符数组1中去，并在末尾加'\0'**，因此strncpy函数可实现字符串的部分复制。当N大于或等于字符串2的长度时，strncpy等价于strcpy

5. 字符串的比较
不能用大于、小于来进行比较，需要用strcmp 、stricmp 、strncmp 、strnicmp等库函数来完成
（1）strcmp函数
`strcmp(字符串1,字符串2);`
功能：比较两个字符串的大小，如果字符串1大于字符串2，则返回一个正整数，如果字符串1小于字符串2，则返回一个负整数；如果字符串相等，则返回0

字符串比较的规则：
>将两个字符串逐一字符比较ASCII码大小，直到遇到不同的字符或者'\0'为止，如果全部字符都相同，这两个字符数组相等。如果出现不相同的字符，则以第一个不相同的字符的比较结果作为判断两个字符数组的大小的标准。

（2）stricmp函数
这个函数调用与strcmp相同，其功能也是比较两个字符串的大小，**但是stricmp函数在比较两个字符串时，不区分大小写**。

（3）strncmp函数
`strncmp(字符串1,字符串2,长度n);`
功能：**将字符串1前N个字符的子串与字符串2前N个子串进行比较**，返回值与strcmp相同

（4）strnicmp函数
**调用与strncmp相同，但是这个不区分大小写**

6. 字符串的连接
`strcat(字符数组1,字符串2);`
功能：将字符串2连接到字符数组1的后面（包括'\0'），其中，字符串2没有变，而字符数组1中的字符将增加了

#### 3. 字符串数组
当构成数组的数据时字符串时，这个数组就称为字符串数组。字符串数组实际上是字符型的二维数组，这个二维数组的每一行都是存放字符串的字符数组。
还可以按照如下的方式进行初始化：
`存储类型符 char 字符串数组名[行数m][列数n] = {字符串1,字符串2,...,字符串m};`
其中，每个字符串的长度应小于n-1（因为字符串的结尾符'\0'占用一个单元）

### 4  本章小结、注意事项
1. 不能用变量来等一数组大小
>int n =10;
>int a[n]; //错误：不能用变量来指定数组的大小

2. 数组赋初值时，需要用{ }，且，{ }中至少有一个值
3. 数组间复制可以使用循环语句赋值，也可以使用memcpy函数来实现
	如果是将一个字符串复制到另一个字符数组中，也可以使用strcpy函数
4. 利用==比较字符串是否相等（X）
>不能用==，需要用strcmp / stricmp函数
>**if(strcmp(str,"wang")==0)**

5. 利用=来进行复制字符串
	需要用strcpy / strncpy 函数
> strcpy(str,"1234");

6. 接受字符串时，使用去地址运算符& （X）
>因为数组本身就是代表地址，因此不需要加上&
>正确 ： scanf("%s",str);


## 第八章 函数
### 1  函数概述

### 2  函数的定义与调用
#### 1. 无参数无返回值的函数
1. 函数的定义
```c
void 函数名(void)
{
	变量声明部分
	执行部分
}
```
2. 函数的用途
3. 函数的原型声明
`void 函数名(void); 或 void 函数名();`
4. 函数的调用
`函数名();`
( )中不能有void
5. 函数的返回
可以利用return
`return(表达式) //有返回值; return 表达式 //有返回值; return //无返回值;`

#### 2. 无参数有返回值的函数
1. 函数的定义
```c
返回值类型符 函数名()
{
	变量声明部分
	执行部分
}
```
>函数的返回值通常是函数计算的结果或执行的状态信息.
>函数的返回值将由 return(表达式)或renturn 表达式 ; 语句返回给调用者(即调用这个函数的另一个函数).表达式的值即是函数的返回值. 一般情况下,表达式的值的类型应与函数返回值类型一致.

2. 函数的用途
3. 函数的原型声明
`返回值类型符 函数名(void); 或 返回值类型符 函数名();`
4. 函数的调用
`函数名(); 或 变量 = 函数名();`

5. 函数的返回
<u>当return(表达式)语句中的表达式的类型与函数的返回值类型不一致时,将表达式的值强制转换成函数返回值的类型.</u>

#### 3.带参数无返回值的函数
1. 函数定义
```c
void 函数名(类型符1 形参名1,类型符2 形参名2 .... )
{
	变量声明部分
	执行部分 	    //这两个部分就是函数体
}
```
>形参类似于函数变量声明部分中的变量,当函数定义时,变量可以有初值,但是形参却没有初值. 当函数被调用时,形参才会有值.

2. 函数的用途
该类函数根据形参的值来进行某种事物的处理. 有了形参之后,调用函数可以把不同处理的值通过形参传递给被调用函数, 被调用函数可以根据形参的值来进行对应的处理.

3. 函数的原型声明
`void 函数名(类型符1 形参名1, 类型符2 形参名2 ....);`
`void 函数名(类型符1 , 类型符2 ....)`

4. 函数的调用
`函数名(实参列表)`
实参列表时用逗号分隔的表达式.
>对于调用带实参的函数时要注意两点:
>实参列表中的实参必须与函数定义时的形参数量相同、类型相同
>实参表求值顺序(即实参赋值给形参的顺序), 因系统而定.

```c
void compare(int a, int b); //also (int ,int) 
void main(){
	int i=2;
  compare(i,i++); //函数调用(i为实参)
  printf("i = %d\n",i);
}

void compare(int a , int b) //函数定义,有形参无返回值(a,b为形参)
{
	printf("a = %d b= %d\n",a,b);
	if(a>b)
		printf("a>b\n");
	else
		if(a == b)
			printf("a=b\n");
		else
			printf("a<b\n");
}
```

5. 函数返回
因为该类型的函数无返回值,所以如果要在函数体内中途返回给条用函数,只有通过 return; 语句返回即可

#### 4. 带参数有返回值的函数
1. 函数的定义
```c
返回值类型 函数名 (类型符1 形参名1, 类型符2 形参名2 ....)
{
	变量声明部分
	执行部分
}
```
>如果省略返回值类型符,默认int 
>函数的返回值将由return(表达式); 或 return 表达式; 语句返回给调用者(调用这个函数的另一个函数)

2. 函数的用途
3. 函数的原型声明 
`返回值类型符 函数名(类型符1 形参名1, 类型符2 形参名2 ....);`
`返回值类型符 函数名(类型符1 , 类型符2 ....)`

4. 函数的调用
`函数名(实参列表);`
`变量名 = 函数名(实参列表)`

```c
int max(int a ,int b);

void main()
{
	int a,b,c;
	scanf("%d%d",&a,&b);
	c = max(a,b);
	printf("the biggest number is %d",c);
	//also write:
	printf("the biggest number is %d",max(a,b));
}

int max(int a ,int b)
{
	return (a>b?a:b);
}
```

5. 函数的返回
函数题内一般会有return(表达式) 或者 return 表达式

### 3  函数参数的传递方式
通常有 <b>值传递方式</b> 和 <b>地址传递方式</b>
1. 运用值传递方式
函数调用时,为形参分配内存单元,并将实参的值复制到形参中.
特点:形参与实参占用不同的内存单元,函数中对形参值的改变不会对实参进行改变. 这就是函数参数的值单向传递规则.

```c
include <stdio.h>
void swap (int a, int b) ;

void main ( )
{
	int x=7, y=11;
	printf ("before swapped: ");
	printf ("x=%d, y=%d\n", x, y);
	swap (x, y);
	printf("after swapped: ") ;
	printf ("x=%d, y=%d\n", x, y) ;
}

void swap (int a, int b)
{
	int temp; 
	temp = a;
	a = b;
	b = temp;
}
```
为什么会出现这种情况,因为在内存单元中没有作任何的改变, 这只是形参在发生改变

2. 运用地址传递方式
函数调用时,将实参数据的存储地址作为参数传递给实参.
特点:形参与实参占用同样的内存单元, 函数中对形参值的改变也会改变实参的值。所以该地址传递的方式可以实现调用函数与被调用函数之间的双向数据传递。
注意:形参和实参必须时地址变量或变量。
比较典型的地址传递方式就是用数组名作为函数的参数,在用数组名作函数参数时,不是进行值的传送,即不是把实参数组的每一个元素的值都赋予形参数组的各个元素. 因为数组名就是数组的首地址,因此在数组名作函数参数时所进行的传送只是地址的传送,也就是说把实参数组的首地址赋予形参数组名

> 注意:
> 形参数组和实参数组的类型必须一致
> 形参数组和实参数组的长度可以不相同,因为在调用时,只传送首地址而不检查形参数组的长度.
> 多为数组也可以作为函数的参数,在函数定义时,对形参数组可以指定每一纬的长度,也可以省去第一纬的长度.

### 4 变量的作用域和生存期
1. 作用域和生存期概念
- 变量的作用域:变量的作用范围(有效范围)
	作用域分: 1. 局部变量 2.全局变量
- 变量的生存期
	变量在程序开始执行开始占用内存,在程序执行的过程中,只有必要时才为变量分配内存. 当变量占用内存时,变量就生成了. 当变量不使用的时候,程序将释放变量所占用的内存,变量就撤销了. 从变量生成到消失的这段时间就是变量的生存期.

2. 局部变量的作用域与生存期
(1) 局部变量
局部变量是在函数内作定义说明的, 作用域仅限于函数内.
>注意:
>主函数 main中定义的变量也是局部变量,只能在主函数中使用,
>形参变量属于被调用函数的局部变量;  
>实参变量属于调用函数的局部变量
>在符合语句中定义的变量也是局部变量,其作用域只在符合语句范围内.

(2)全局变量
全局变量也为 外部变量.
作用域是从变量定义处到程序文件的末尾
>全局变量可加强函数模块之间的数据关系,使得这些函数依赖于全局变量,让函数的独立性降低.
>在同一文件中,全局和局部变量可以一样,如果使用全局变量,则必须在变量名前加上两个冒号 ‘::’
>引用全局变量: `extern 类型说明符 全局变量名1 , ..... 全局变量名n ;`


### 5 变量的存储类型
静态存储类型的变量:通常是在变量定义时就分配内存单元并一直保持不变,直至整个程序结束. (全局变量就是这种)
动态存储类型变量:使用时才分配,使用完立即释放 (形式参数)
>auto(自动型)
>register(寄存器型)
>extern(外部型)
>static(静态型)

1. 自动变量(auto)
说明符为auto, 属于动态存储类型
`[auto] 数据类型说明符 变量名1, 变量名2,....变量名n`
auto可以省略, 自动变量只能在函数内或复合语句中定义 --->属于局部变量
注意: 在函数外部定义的没有带存储类型说明符的全局变量,如 int k; 并不代表是自动变量,而是外部变量,属于静态存储类型.

2. 外部变量(extern)
属于静态存储类型

3. 静态变量(static)
属于静态存储类型的变量不一定就是静态变量.
(1)静态局部变量
在局部变量的说明前加上static 就构成静态局部变量
`static int a, b;`
`static float array[5] = {1,2,3,4,5};`
- 静态局部变量属于静态存储方式,它与自动变量相比有以下特点:
>静态局部变量与自动变量均属于局部变量,都是在函数内或复合语句中定义.但自由变量是在调用函数或指定复合语句时才生成,推出函数或者符合语句时就消失. 而静态局部变量时在调用函数或执行复合语句之前就生成,退出函数或复合语句后仍然存在, 变量将保持现有的值, 直到程序终止时才消失. <u>它的生存周期为整个源程序.</u>
>静态局部变量作用域与自动变量相同.
>对静态局部变量若在定义时为赋初值, 则系统自动赋初值0。
>虽然离开定义它的函数后不能使用,但是在此调用定义它的函数时候,它还可以继续使用,并不会被消除,而且保存了前次被调用后留下的值.

(2)静态全局变量
全局变量(外部变量)的说明之前再冠以static就构成了静态全局变量. 全局变量本身就是静态存储方式.
主要的区别:
- 非静态全局变量的作用域是整个源程序,当一个源程序由多个源文件组成时,非静态的全局变量在各个源文件中通过外部变量说明都是有效的
- 静态全局变量则限制了其作用域,即只在定义该变量的源文件内有效,在同一源程序的其他源文件中不能通过外部变量说明来使用它.

4. 寄存器变量(register)
这个放在CPU的寄存器中,使用时,不需要访问内存,直接从寄存器中读写,这样可提高效率.
说明:
>只有局部自动变量和形式参数才可以定义为寄存器变量. 
>寄存器变量属于动态存储类型

### 6 函数的嵌套和递归调用
1. 运用函数的嵌套调用
  示意图
  ![](picture/8.6.png)

```c
//计算三个数中最大数与最小数的差
#include<stdio.h>

int dif(int x, int y, int z);
int max(int x, int y, int z);
int min(int x, int y, int z);

void main()
{
	int a, b, c, d;
	scanf("%d%d%d",&a,&b,&c);
	d = dif(a,b,c);
	printf("Max - Min = %d\n",d);
}

int dif(int x, int y, int z)  //求三数中的最大值与最小值的差
{
	return (max(x,y,z)-min(x,y,z));
}

int max(int x, int y, int z) // find max number
{
	int r;
	r = x > y ? x : y;
  return (r > z ? r : z);
}

int min(int x, int y, int z)
{
	int r;
	r = x < y ? x : y;
	return(r < z ? r : z);
}
```

2. 运用函数的递归调用
  直接递归调用和间接递归调用
  ![](picture/8.6_2.png)
  说明:
>递归函数主要用于解决具有递归性质的问题
>每调用函数一次,在内存堆栈区需分配空间,用于存放函数变量、返回值等信息.

```c
//打印数字三角形
#include<stdio.h>

void printf(int w);

void main()
{
	int i;
	if(w!=0)  //递归结束的条件
	{
		print(w-1);
		for(i = 1; i <= w; ++i){
			prtinf("%d",w);
		}
		printf("\n");
	}
}

```

```c
	//求N的阶乘 N!
	/*
	1. 可以用for 做出一个非递归函数 factn1
	long factn1(int n)
	{
		long L =1;
		int i;
		for(i=1;i<=n;i++){
			L *=i;
		}
		return(L);
	}
	*/
	//2. 用递归函数来写
	long fact(int n) //递归函数求n!
	{
		long L;
		if(n==1)
			return(1);
		L = n* fact(n-1);
		retrun(L);
	}
	
	//主函数
	void main()
	{
		int n;
		long L;
		scanf("%d",&n);
		L = fact(n);
		printf("%d! = %ld\n",n,L);
	}
```

![](picture/8.6_3.png)
[递归调用及堆栈变化示意图(factn1)]

![](picture/8.6_4递归.png)
[递归调用示意图( fact( ) )]

编写递归函数有两个要点:
>1. 确定递归公式, 是实现递归函数的模版
>2. 根据公式确定递归函数的出口,即结束递归调用的条件

### 7 函数的作用域
1. 内部函数
内部函数: 如果在一个源文件中定义的函数只能被本文件中的函数调用,而不能被同一源程序其他文件中的函数调用.
`static 类型说明符 函数名(形参表)`
例如:
```c
	static int func(int a, int b)
	{
		return (a > b ? a : b);
	}
```
内部函数也称静态函数,但此处静态static的含义不是指存储类型,而是指对函数的作用域只局限于本文件.

2. 外部函数
外部函数在整个源程序中都有效
`extern 类型说明符 函数名(形参表)`
如果函数定义中没有说明extern或static 则隐含为 extern.

## 第9章 指针
### 1 指针与指针变量的概念
1. 内存地址——内存中存储单元的编号











